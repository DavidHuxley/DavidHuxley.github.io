---
title: Arrow, Regular Functions 
date: 2023-06-13 17:25:00 +0900
categories: [JavaScript]
tags: [Javascript, ES6, Arrow Function]     # TAG names should always be lowercase
---

삭제기능을 구현하던 중 fadeOut이 제대로 작동되지 않는 상황이 생겼다. 

![](https://velog.velcdn.com/images/huxleyseo/post/8f963602-f28d-49f8-a992-244291435336/image.png)

확인해보니 DB의 데이터가 실제로 삭제되었고 브라우저와 터미널에도 로그가 잘 뜨는것을 확인했다. 그렇다면 저 간단한 jQuery 메소드 하나가 작동을 안한다는것인데 그 이유는 생각보다 간단했다.

#### 결론부터

ES6부터 추가된 화살표 함수를 제대로 알아보지않고 아무 생각없이 사용했던게 문제였다.

JS에서 모든 함수는 실행될 때 마다 this라는 객체가 추가되는데, this라는 객체에 바인딩 되는 데이터가 일반 함수와 화살표 함수가 다르기 때문이다.

이참에 일반적인 함수 호출시 this에 어떻게 바인딩이 되는지 간단히 정리해보자.

---
### 일반 함수

#### 1. 함수 호출시 this는 전역객체에 바인딩
 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다. 
정확히는 this가 지정되지 않는것인데 지정되지 않은 this는 자동으로 전역 객체를 가리키기 때문.
이는 JS개발자 중 한명인 더글라스 크락포드가 설계상의 결함이라고 "메소드가 내부함수를 사용하여 자신의 작업을 돕게 할 수 없다는 것을 의미한다" 라고 말했다고 한다.

#### 2. 메소드 호출시 해당 메소드 내부에 위치한 this는 소유한 객체에 바인딩
함수가 객체의 property 값이면 메소드로 호출되는데 이때는 내부의 this가 해당 메소드를 호출한(메소드를 소유하고 있는) 객체에 바인딩 된다.

#### 3. 생성자 함수는 생성되는 객체에 바인딩
대부분 상황에서 생성자 함수는 new 연산자를 함께쓸거고 그렇게 호출한다면 this는 생성자 함수가 생성한 빈 객체에 바인딩 된다, new 없이 호출하면 해당 생성자 함수의 this는 전역객체에 바인딩된다.

#### etc. apply/call/bind 호출시 특정 객체에 바인딩
this에 바인딩 되는 객체는 위의 예시처럼 함수 호출 패턴에 따라서 자바스크립트 엔진에 의해 암묵적으로 바인딩된다. 그렇지만 this를 특정 객체에 명시적으로 바인딩 하는 방법도 제공되는데 이것이 apply, call, bind 메소드이다. 
해당 메소드에 대해서 정리를 하면 내용이 너무 길어지므로  [Reference](https://poiemaweb.com/js-this)만 남겨놓고 필요시 다시한번 정리 해보는걸로.

---

이처럼 일반 함수에서 this는 바인딩되는 객체가 정적이지 않고 호출 패턴에 따라서 다르게 바인딩된다.

### 화살표 함수

그렇지만 화살표 함수는 선언 시점에서 정적으로 this가 바인딩 하는 객체가 결정된다. 정확히 말하자면 **화살표 함수에서 this는 존재하지 않기 때문에 그 바로 상위 스코프의 this를 참조한다.**

어.
문제의 메소드에서 this에 바인딩 된것은 바로 전역객체가 아니였던가. 
아차 싶어서 로그를 찍어보니 당연하게도 window가 찍힌다. 윈도우의 부모요소 li라니.. 

![](https://velog.velcdn.com/images/huxleyseo/post/bbf7af43-1226-4d78-adbe-ae0ba12c8553/image.png)

화살표 함수를 일반 함수로 수정하니까 예쁘게 잘 실행된다.

마지막으로 화살표 함수를 쓰면 안되는 상황만 간단하게 정리해보자.

- 생성자
생성자 함수는 화살표 함수로 사용할 수 없다. prototype property가 없기 때문
- argument 
일반 함수와 다르게 암묵적으로 arguments 변수가 전달되지 않기 때문에 화살표 함수는 사용할 수 없다. 실제로 로그를 띄워보면 arguments를 정의할 수 없다고 뜸

그 외에 메소드에서 화살표 함수를 사용하면 상위 스코프의 전역객체를 가리킨다거나, addEventListener() 와 같은 이미 this의 값이 정해져있는 콜백함수의 경우에도 화살표 함수를 사용하면 this에 바인딩 된 값이 사라지고 상위 스코프를 바라본다. 이러면 원하는대로 동작하지 않을 가능성이 매우 높기 때문에 주의해야한다.

